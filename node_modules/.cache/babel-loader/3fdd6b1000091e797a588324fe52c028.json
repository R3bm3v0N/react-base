{"ast":null,"code":"export { configureStore } from 'redux-starter-kit';\nimport { __assign } from 'tslib';\nimport { filter } from 'rxjs/operators';\n/**\n * Flux standard action factory\n * @example\n * const clearTodos = action('[Todo] truncate');\n * @example\n * const fetchTodosRejected = (payload: Error) => action('[Todo] fetch rejected', payload);\n * @example\n * const addTodo = ({ name, completed = false }: Todo) => action('[Todo] add', { name, completed });\n * @example\n * const fetchTodosRejected = (payload: Error, meta?: Meta) => action('[Todo] fetch rejected', payload, meta);\n * @example\n * const addTodo = ({ name, completed = false }: Todo, meta?: Meta) => action('[Todo] add', { name, completed }, meta);\n */\n\nfunction createAction(type, payload, meta) {\n  return __assign({\n    type: type\n  }, payload !== undefined ? {\n    payload: payload\n  } : {}, meta !== undefined ? {\n    meta: meta\n  } : {}, payload instanceof Error ? {\n    error: true\n  } : {});\n}\n/**\n * Flux standard action creator factory\n * @example\n * createActionCreator('[Todo] truncate');\n * @example\n * createActionCreator(\n *   '[Todo] fetch rejected',\n *   resolve => (error: Error) => resolve(error)\n * );\n * @example\n * createActionCreator(\n *   '[Todo] fetch rejected',\n *   resolve => (error: Error, meta?: { status: number }) => resolve(error, meta)\n * )\n * @example\n * createActionCreator(\n *   '[Todo] add',\n *   resolve => (name: string, completed = false) => resolve({ name, completed })\n * )\n * @example\n * createActionCreator(\n *   '[Todo] add',\n *   resolve => (name: string, completed = false) => resolve({ name, completed }, 'Meta data of all todos')\n * )\n *\n */\n\n\nfunction createActionCreator(type, executor) {\n  if (executor === void 0) {\n    executor = function executor(resolve) {\n      return function () {\n        return resolve();\n      };\n    };\n  }\n\n  var callable = executor(function (payload, meta) {\n    return createAction(type, payload, meta);\n  });\n  return Object.assign(callable, {\n    type: type,\n    toString: function toString() {\n      return type;\n    }\n  });\n}\n/**\n * Map action creator to it's contained action type\n * @description it gets an object with at least a type property or overridden toString method and returns it.\n * @example\n * const increment = createActionCreator('[Counter] increment')\n * getType(increment) //=> '[Counter] increment'\n * @example\n * getType({ type: 'TEST' }) //=> 'TEST'\n * @example\n * getType({\n *  toString() { return 'TEST' }\n * }) //=> 'TEST'\n */\n\n\nfunction getType(actionCreator) {\n  if (!actionCreator.type && !actionCreator.hasOwnProperty('toString')) {\n    throw new Error(\"Action creator that has been passed to getType() does not provide any API to expose action type. You can use createAction() to create an action creator without any unsense errors.\");\n  }\n\n  return actionCreator.type || actionCreator.toString();\n}\n/**\n * Handler map factory\n * @description create an action(s) to reducer map\n * @example\n * createHandlerMap(increment, (state: number) => state + 1)\n * @example\n * createHandlerMap([increment, increase], (state: number) => state + 1)\n */\n\n\nvar createHandlerMap = function createHandlerMap(actionCreators, handler) {\n  return (Array.isArray(actionCreators) ? actionCreators : [actionCreators]).map(getType).reduce(function (acc, type) {\n    acc[type] = handler;\n    return acc;\n  }, {});\n};\n\nvar merge = function merge() {\n  var objs = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    objs[_i] = arguments[_i];\n  }\n\n  return Object.assign.apply(Object, [{}].concat(objs));\n};\n/**\n * Reducer factory\n * @description combines multiple handler map into single reducer\n * @example\n * const counter = createReducer(0, handleAction => [\n *   handleAction(increment, state => state + 1),\n *   handleAction(decrement, state => state - 1),\n * ])\n */\n\n\nfunction createReducer(defaultState, handlerMapsCreator) {\n  var handlerMap = merge.apply(void 0, handlerMapsCreator(createHandlerMap));\n  return function (state, action) {\n    if (state === void 0) {\n      state = defaultState;\n    }\n\n    var handler = handlerMap[action.type];\n    return handler ? handler(state, action) : state;\n  };\n}\n/**\n * Filter actions emitted by the source Observable by only emitting those that\n * are compatible with specified action(s) or action creator(s) or action type(s).\n *\n * @example\n * action$.pipe(\n *   ofType(foo),\n *   ...\n * )\n * @example\n * action$.pipe(\n *   ofType([foo, bar]),\n *   ...\n * )\n */\n\n\nfunction ofType(keys) {\n  var types = (Array.isArray(keys) ? keys : [keys]).map(function (key) {\n    return typeof key === 'string' ? key : getType(key);\n  });\n  return filter(function (action) {\n    return types.includes(action.type);\n  });\n}\n\nexport { createAction as action, createActionCreator as createAction, createActionCreator, createReducer, getType, ofType };","map":null,"metadata":{},"sourceType":"module"}