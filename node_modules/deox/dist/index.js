'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var reduxStarterKit = require('redux-starter-kit');
var tslib_1 = require('tslib');
var operators = require('rxjs/operators');

/**
 * Flux standard action factory
 * @example
 * const clearTodos = action('[Todo] truncate');
 * @example
 * const fetchTodosRejected = (payload: Error) => action('[Todo] fetch rejected', payload);
 * @example
 * const addTodo = ({ name, completed = false }: Todo) => action('[Todo] add', { name, completed });
 * @example
 * const fetchTodosRejected = (payload: Error, meta?: Meta) => action('[Todo] fetch rejected', payload, meta);
 * @example
 * const addTodo = ({ name, completed = false }: Todo, meta?: Meta) => action('[Todo] add', { name, completed }, meta);
 */
function createAction(type, payload, meta) {
    return tslib_1.__assign({ type: type }, (payload !== undefined ? { payload: payload } : {}), (meta !== undefined ? { meta: meta } : {}), (payload instanceof Error ? { error: true } : {}));
}

/**
 * Flux standard action creator factory
 * @example
 * createActionCreator('[Todo] truncate');
 * @example
 * createActionCreator(
 *   '[Todo] fetch rejected',
 *   resolve => (error: Error) => resolve(error)
 * );
 * @example
 * createActionCreator(
 *   '[Todo] fetch rejected',
 *   resolve => (error: Error, meta?: { status: number }) => resolve(error, meta)
 * )
 * @example
 * createActionCreator(
 *   '[Todo] add',
 *   resolve => (name: string, completed = false) => resolve({ name, completed })
 * )
 * @example
 * createActionCreator(
 *   '[Todo] add',
 *   resolve => (name: string, completed = false) => resolve({ name, completed }, 'Meta data of all todos')
 * )
 *
 */
function createActionCreator(type, executor) {
    if (executor === void 0) { executor = function (resolve) { return (function () { return resolve(); }); }; }
    var callable = executor(function (payload, meta) {
        return createAction(type, payload, meta);
    });
    return Object.assign(callable, {
        type: type,
        toString: function () {
            return type;
        },
    });
}

/**
 * Map action creator to it's contained action type
 * @description it gets an object with at least a type property or overridden toString method and returns it.
 * @example
 * const increment = createActionCreator('[Counter] increment')
 * getType(increment) //=> '[Counter] increment'
 * @example
 * getType({ type: 'TEST' }) //=> 'TEST'
 * @example
 * getType({
 *  toString() { return 'TEST' }
 * }) //=> 'TEST'
 */
function getType(actionCreator) {
    if (!actionCreator.type && !actionCreator.hasOwnProperty('toString')) {
        throw new Error("Action creator that has been passed to getType() does not provide any API to expose action type. You can use createAction() to create an action creator without any unsense errors.");
    }
    return (actionCreator.type || actionCreator.toString());
}

/**
 * Handler map factory
 * @description create an action(s) to reducer map
 * @example
 * createHandlerMap(increment, (state: number) => state + 1)
 * @example
 * createHandlerMap([increment, increase], (state: number) => state + 1)
 */
var createHandlerMap = function (actionCreators, handler) {
    return (Array.isArray(actionCreators) ? actionCreators : [actionCreators])
        .map(getType)
        .reduce(function (acc, type) {
        acc[type] = handler;
        return acc;
    }, {});
};

var merge = function () {
    var objs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        objs[_i] = arguments[_i];
    }
    return Object.assign.apply(Object, [{}].concat(objs));
};

/**
 * Reducer factory
 * @description combines multiple handler map into single reducer
 * @example
 * const counter = createReducer(0, handleAction => [
 *   handleAction(increment, state => state + 1),
 *   handleAction(decrement, state => state - 1),
 * ])
 */
function createReducer(defaultState, handlerMapsCreator) {
    var handlerMap = merge.apply(void 0, handlerMapsCreator(createHandlerMap));
    return function (state, action) {
        if (state === void 0) { state = defaultState; }
        var handler = handlerMap[action.type];
        return handler ? handler(state, action) : state;
    };
}

/**
 * Filter actions emitted by the source Observable by only emitting those that
 * are compatible with specified action(s) or action creator(s) or action type(s).
 *
 * @example
 * action$.pipe(
 *   ofType(foo),
 *   ...
 * )
 * @example
 * action$.pipe(
 *   ofType([foo, bar]),
 *   ...
 * )
 */
function ofType(keys) {
    var types = (Array.isArray(keys) ? keys : [keys]).map(function (key) {
        return typeof key === 'string' ? key : getType(key);
    });
    return operators.filter(function (action) { return types.includes(action.type); });
}

Object.defineProperty(exports, 'configureStore', {
    enumerable: true,
    get: function () {
        return reduxStarterKit.configureStore;
    }
});
exports.action = createAction;
exports.createAction = createActionCreator;
exports.createActionCreator = createActionCreator;
exports.createReducer = createReducer;
exports.getType = getType;
exports.ofType = ofType;
